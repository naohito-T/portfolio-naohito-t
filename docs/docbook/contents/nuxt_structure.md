# 5. nuxt structure

## nuxt ディレクトリ構成

[リファレンス](https://ja.nuxtjs.org/docs/2.x/get-started/directory-structure)

- pages ディレクトリ
  pages ディレクトリにはアプリケーションのビューとルートが含まれている
  Nuxt.js はこのディレクトリ内の.vue ファイルを全て読み込み、アプリケーションのルーターを作成する。

- components ディレクトリ
  components ディレクトリにはページにインポートする全ての Vue.js のコンポーネントファイルを入れる
  Nuxt.js を使用すると作成したコンポーネントを.vue ファイルに自動でインポートすることができる。
  nuxt.config.js 内の components を true に設定すると Nuxt.js がスキャンして自動でインポートしてくれる。

- layout ディレクトリ
  layout ディレクトリの default ファイルを追加することでデフォルトレイアウトを定義できる。
  これは特定のレイアウトを持たない全てのページで使用される。
  レイアウトに含める必要があるのは、ページコンポーネントをレンダリングする`<Nuxt />`だけ

## SPA・SSR・SSG とは

[URL](https://qiita.com/nishinoshake/items/f42e2f03663b00b5886d)

Nuxt.js では SPA・SSR・SSG の中から好きなものを選んで開発ができる
初期設定では SSR で動作するようになっている。

SPA(Single Page Application)

- メリット
  実装しやすい
  サーバの準備が楽
  SPA は、最もシンプルに実装でき、ホスティング先の選択肢が多いのが魅力です。
  ドキュメントで、Netlify や GitHub Pages へのデプロイ方法が紹介されていますが、単にファイルをアップすればいいだけなので、ロリポップのようなレンタルサーバーでも動きます

- デメリット
  初期表示が遅い
  SEO に不安がある
  OG をページごとに設定ができない

SSR(Single Side Rendering)

- メリット
  SPA の欠点を解消できる

- デメリット
  実装が SPA より面倒
  サーバーの準備が面倒

  初回のリクエストをサーバーサイドでレンダリングして返すため、SPA の欠点を補うことができます。一方で、レンダリングするためのサーバーと、SSR を考慮した実装が必要になります。
  ドキュメントで、Heroku や Now へのデプロイ方法が紹介されていますが、Node.js が動作するサーバーを用意できればなんでも大丈夫です。インフラに弱い人にはこのハードルが高い気がしますが、インフラに強い人や、好きな PaaS がある人にとっては、SSR が魅力的な選択肢になると思います。

SSG(Static Site Generation)

- メリット
  SPA の欠点を解消できる
  **サーバーの準備が楽**
  SSR よりも速い
  更新が少ない Web サイト
  ドキュメントやブログ

- デメリット
  実装が少し面倒
  用途が限られる

各ルートの HTML をあらかじめ生成するため、SSR よりもレスポンスが速いのが魅力です。また、静的ファイルを生成するおかげで、SPA と同じようにホスティング先の選択肢が広がります。

生成時にはサーバーサイドでレンダリングすることになるので、SSR を考慮した実装が必要になるのと、SSG には向き不向きがあるので、Web サイトの要件を考えて慎重に選択する必要があります。

## Vue の歴史

Vue2.x ではコンポーネントを SFC(シングルファイルコンポーネント)ファイルに記述する
SFC にコンポーネントの View/状態/ロジックをまとめて閉じ込めて記述することできて便利だが
これ以上は分割ができないという欠点があった。
これを解決するのが Composition API

Composition API によってコンポーネントのコードを整理する際に開発者により高い柔軟性を提供する。
コンポーネント間でロジックや状態を抽出して再利用することが簡単になる。

SFC に記述するのは View の見た目に関することだけにして、ロジックや状態を外部に切り出せるようになる。

つまり、SFC には View の見た目に関することだけを記述していく。

## composition API においての Provider パターン

[参考 URL](https://qiita.com/karamage/items/4bc90f637487d3fcecf0)

- Provider パターンとは
  Vue における Provider パターンとは provide/inject API を使用して Composition API で切り出した状態やロジックをコンポーネント間で共有することを指す。

## provide/inject の使い方

提供する側(provide)と注入する側(inject)に分かれる

- 送信側(provide)
  親コンポーネントで送信を定義

- 受信側(inject)
  親コンポーネントから呼び出されている子コンポーネントは inject(key)で使用する。

## 今後 Provider の API は変わるかも

もともと Plugin 開発やライブラリ開発向けの API として「provide/inject」が用意されていました。
つまり、「provide/inject」は Vue3 用に用意された API ではないのです。
よって、Provider の仕組みは、今後、変わるかもしれません。
「provide/inject」仕組みは、問題点も多いからです。
例えば Key を書き間違えたら不具合を引き起こしますが、それが実行時にしかわからないです。
inject の対象がコンポーネント単位のため、依存が大きいです。(もっと依存度を下げて使いたい)
今後 Vue3 で改善されると予想しています。

しかし、抽象レベルの「Provider パターン」の考え方は変わりませんので、知っておいて損はないかと思います。

- まとめ
  Composition API を使って、散らかった部屋の荷物をダンボールに梱包して、外に出そう。
  Composition API を使って梱包した荷物を運ぶのが Provider の役目
  Provider で、親コンポーネントから子コンポーネントに共通の状態を簡単に受け渡すことができる。
  Prop 渡しと違ってバケツリレーをする必要がない。
  今後、Vue3 では Provider の改善が進むと予想

## Vuex と Provider の使い分け

> もちろん Vuex の使用が適切なパターンもありますが、以下の場合においては Provide/Inject のようなパターンで検討することも一つの手だと思います。
> コンポーネントのネストが深いが、props/emit のバケツリレーを避けたい
> Provide した値のスコープがある程度限定的

## Nuxt 処理の共通化

Vue.js での処理の共通化といったら Mixin が有名
しかし、asyncData 関数の中では参照することができなかったり、TS でデコレータを使用している場合は Vue インスタンスで Mixins クラスを継承する必要があったりと少し不便。

Nuxt の plugin を実装することで DI っぽいことをしてどこでも関数が使えることがわかった。

[処理の共通化参照](https://qiita.com/misaosyushi/items/3690a63eb35cb5c14c50)
